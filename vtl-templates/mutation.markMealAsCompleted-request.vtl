#### START CONTENT OF mutation.markMealAsCompleted-request.vtl
## Mutation: markMealAsCompleted(input: MarkMealCompletedInput!)
## Action: Update/Create PlanDayCompletion item, ADD mealName to completedMealNames set.

#set($userId = $ctx.identity.sub)
#if(!$userId || $userId == "")
  $util.unauthorized()
#end

#set($input = $ctx.args.input)
#set($mealPlanId = $input.mealPlanId)
#set($mealName = $input.mealName) ## This is MealNameEnum (e.g., "BREAKFAST")
#set($date = $input.date) ## Optional date from input

#if(!$mealPlanId || $mealPlanId == "")
    $util.error("mealPlanId is required.", "ValidationException")
#end
#if(!$mealName || $mealName == "")
    $util.error("mealName is required.", "ValidationException")
#end

## Determine date to use
#set($dateToUse = $date)
#if(!$dateToUse || $dateToUse == "")
  #set($utils = $util.time)
  #set($dateToUse = $utils.nowISO8601().substring(0, 10)) ## Defaults to today YYYY-MM-DD
#end

#set($pk = "USER#" + $userId)
#set($sk = "PDC#" + $mealPlanId + "#" + $dateToUse)

#set($nowISO = $util.time.nowISO8601())

## Prepare UpdateItem
#set($values = {
  ":newMealName": $util.dynamodb.toStringSet([$mealName]), ## Value for ADD (must be a Set)
  ":userIdValue": $util.dynamodb.toDynamoDB($userId),
  ":planIdValue": $util.dynamodb.toDynamoDB($mealPlanId),
  ":dateValue": $util.dynamodb.toDynamoDB($dateToUse),
  ":updatedAtValue": $util.dynamodb.toDynamoDB($nowISO),
  ":gsi4pkValue": $util.dynamodb.toDynamoDB("USER#" + $userId),
  ":gsi4skValue": $util.dynamodb.toDynamoDB("DATE#" + $dateToUse + "_PLAN#" + $mealPlanId),
  ":emptySet": $util.dynamodb.toStringSet([]) ## For initializing completedMealNames if it doesn't exist
})

#set($expressionNames = {
  "#cmn": "completedMealNames",
  "#uid": "userId",
  "#pid": "planId",
  "#dt": "date",
  "#ua": "updatedAt",
  "#gsi4pk": "GSI4PK", ## Literal GSI attribute name
  "#gsi4sk": "GSI4SK"  ## Literal GSI attribute name
})

## Use ADD operation for completedMealNames.
## Initialize other attributes using SET and if_not_exists.
#set($updateExpression = "SET #uid = if_not_exists(#uid, :userIdValue), ")
$util.qr($updateExpression.append("#pid = if_not_exists(#pid, :planIdValue), "))
$util.qr($updateExpression.append("#dt = if_not_exists(#dt, :dateValue), "))
$util.qr($updateExpression.append("#gsi4pk = if_not_exists(#gsi4pk, :gsi4pkValue), "))
$util.qr($updateExpression.append("#gsi4sk = if_not_exists(#gsi4sk, :gsi4skValue), "))
$util.qr($updateExpression.append("#ua = :updatedAtValue ")) ## Always update 'updatedAt'
## Initialize completedMealNames as an empty set if it doesn't exist, then ADD to it.
## This two-step approach (if_not_exists for init, then ADD) is safer than just ADD.
$util.qr($updateExpression.append("ADD #cmn :newMealName "))
$util.qr($updateExpression.append("SET #cmn = if_not_exists(#cmn, :emptySet)")) ## This SET comes after ADD in evaluation logic

## The actual expression for DynamoDB needs to be carefully constructed.
## A more robust way for SET if_not_exists and ADD:
#set($updateExpression = "SET #uid = if_not_exists(#uid, :userIdValue), #pid = if_not_exists(#pid, :planIdValue), #dt = if_not_exists(#dt, :dateValue), #gsi4pk = if_not_exists(#gsi4pk, :gsi4pkValue), #gsi4sk = if_not_exists(#gsi4sk, :gsi4skValue), #ua = :updatedAtValue, #cmn = if_not_exists(#cmn, :emptySet) ADD #cmn :newMealName")


{
  "version": "2018-05-29",
  "operation": "UpdateItem",
  "key": {
    "PK": $util.dynamodb.toDynamoDBJson($pk),
    "SK": $util.dynamodb.toDynamoDBJson($sk)
  },
  "update": {
    "expression": $updateExpression,
    "expressionNames": $expressionNames,
    "expressionAttributeValues": $values
  },
  "returnValues": "ALL_NEW" ## Return the updated PlanDayCompletion item
}
#### END CONTENT OF mutation.markMealAsCompleted-request.vtl