/**
 * ===================================================================
 * Lambda: generator_handler.ts (v3 - Using Gemini JSON Mode)
 * ===================================================================
 * This Lambda runs asynchronously to generate the meal plan using the
 * Google GenAI SDK with JSON schema enforcement for reliable output.
 *
 * Required Environment Variables:
 * - TABLE_NAME: The name of the DynamoDB Single table.
 * - GEMINI_SECRET_ARN: The ARN of the secret containing the Gemini API key.
 * - AWS_REGION: The AWS region the Lambda and AppSync API are in.
 *
 * Required `package.json` dependencies:
 * "dependencies": {
 * "@google/genai": "^0.12.0",
 * "@aws-sdk/client-secrets-manager": "^3.525.0",
 * "@aws-sdk/credential-providers": "^3.525.0",
 * "@aws-sdk/signature-v4": "^3.525.0",
 * "@aws-crypto/sha256-js": "^5.2.0",
 * "node-fetch": "^2.6.7"
 * },
 * "devDependencies": {
 * "@types/aws-lambda": "^8.10.136",
 * "@types/node-fetch": "^2.6.2"
 * }
 * ===================================================================
 */

import { GoogleGenAI } from "@google/genai";
import { MealPlanSchema } from "./MealPlanSchema";

import {
  SecretsManagerClient,
  GetSecretValueCommand,
} from "@aws-sdk/client-secrets-manager";
import { Handler } from "aws-lambda";
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";

// Types are generated by `npm run codegen`
import {
  DailyPlanData,
  PlanRequestPreferencesInput,
  UserDetails,
  ExerciseFrequency,
  PlanStatus,
} from "../graphql-types";
import console from "console";
import {
  DynamoDBDocumentClient,
  QueryCommand,
  QueryCommandOutput,
  UpdateCommand,
} from "@aws-sdk/lib-dynamodb";

// Get environment variables
const { TABLE_NAME, GEMINI_SECRET_ARN, AWS_REGION } = process.env;

// Initialize the DynamoDB client
const dynamoDbClient = new DynamoDBClient({});
const docClient = DynamoDBDocumentClient.from(dynamoDbClient);

// Memoize the API key to avoid fetching it on every cold start
let geminiApiKey: string | null = null;

interface GeneratorEvent {
  mealPlanId: string;
  userId: string;
  preferences: { [key: string]: any };
}

function calculateAge(dateOfBirth: string): number {
  const today = new Date();
  const birth = new Date(dateOfBirth);
  let age = today.getFullYear() - birth.getFullYear();
  const monthDiff = today.getMonth() - birth.getMonth();

  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
}

async function getGeminiApiKey(): Promise<string> {
  // ... (function remains the same as previous version)
  if (geminiApiKey) return geminiApiKey;
  if (!GEMINI_SECRET_ARN)
    throw new Error("GEMINI_SECRET_ARN environment variable not set.");

  const secret_name = "GeminiApiSecret";

  const client = new SecretsManagerClient({
    region: AWS_REGION || `us-west-2`,
  });

  let response;

  try {
    response = await client.send(
      new GetSecretValueCommand({
        SecretId: secret_name,
        VersionStage: "AWSCURRENT", // VersionStage defaults to AWSCURRENT if unspecified
      }),
    );
  } catch (error) {
    // For a list of exceptions thrown, see
    // https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_GetSecretValue.html
    throw error;
  }

  const secret = response.SecretString;
  if (!secret) {
    throw new Error(`Secret ${secret_name} not found or empty.`);
  }
  console.log("Fetched apikey secret successfully");
  const apiKey = JSON.parse(secret)[secret_name];
  if (!apiKey) {
    throw new Error(`API key not found in secret ${secret_name}.`);
  }
  geminiApiKey = apiKey;
  return geminiApiKey!;
}

function buildUserPrompt(preferences: PlanRequestPreferencesInput): string {
  // Drop dateOfBirth and replace it with age
  const dateOfBirth = preferences.dateOfBirth!;
  let age = `${calculateAge(dateOfBirth)}`;

  // Build the preferences string
  const prefs: { [key: string]: any } = {
    "Daily Meals Preference": preferences.dailyMealsPreference,
    "Exercise Frequency": preferences.exerciseFrequency,
    "Height (cm)": preferences.heightCm,
    "Weight (kg)": preferences.weightKg,
    Allergies:
      preferences.allergies && preferences.allergies.length > 0
        ? preferences.allergies.join(", ")
        : "None",
    "Dietary Restrictions": preferences.dietaryRestrictions || "None",
    "User Preferences": preferences.openTextPreferences || "None",
    "Age (years)": age,
  };

  const prefsStr = Object.entries(prefs)
    .map(([key, value]) => `${key}: ${value}`)
    .join("\n");

  return `Generate a weekly meal plan based on the following details:\n ${prefsStr}.`;
}

function buildUserPreferencesForGenerator(
  userDetails: UserDetails,
  preferences: PlanRequestPreferencesInput,
): PlanRequestPreferencesInput {
  // Prepare the preferences object for the generator
  const userPreferences: PlanRequestPreferencesInput = {
    allergies: preferences.allergies || userDetails.allergies || [],
    dailyMealsPreference:
      preferences.dailyMealsPreference || userDetails.dailyMealsPreference || 3,
    dietaryRestrictions:
      preferences.dietaryRestrictions || userDetails.dietaryRestrictions,
    exerciseFrequency:
      preferences.exerciseFrequency ||
      userDetails.exerciseFrequency ||
      ExerciseFrequency.NOT_SPECIFIED,
    heightCm: preferences.heightCm || userDetails.heightCm,
    weightKg: preferences.weightKg || userDetails.weightKg,
    openTextPreferences:
      preferences.openTextPreferences || userDetails.openTextPreferences || "",
    dateOfBirth: preferences.dateOfBirth || userDetails.dateOfBirth,
  };

  return userPreferences;
}

function validateUserPreferences(
  userPreferences: PlanRequestPreferencesInput,
): void {
  // Validate the user preferences object
  if (!userPreferences) {
    throw new Error("User preferences are required.");
  }

  if (
    !userPreferences.dailyMealsPreference ||
    userPreferences.dailyMealsPreference < 1 ||
    userPreferences.dailyMealsPreference > 6
  ) {
    throw new Error("Daily meals preference must be between 1 and 6.");
  }

  if (!userPreferences.exerciseFrequency) {
    throw new Error("Exercise frequency is required.");
  }

  if (
    !userPreferences.heightCm ||
    userPreferences.heightCm < 50 ||
    userPreferences.heightCm > 250
  ) {
    throw new Error("Height must be provided and be between 50 and 250 cm.");
  }

  if (
    !userPreferences.weightKg ||
    userPreferences.weightKg < 30 ||
    userPreferences.weightKg > 300
  ) {
    throw new Error("Weight must be provided and be between 30 and 300 kg.");
  }

  if (!userPreferences.allergies || !Array.isArray(userPreferences.allergies)) {
    throw new Error("Allergies must be an array.");
  }

  if (
    userPreferences.allergies.some((allergy) => typeof allergy !== "string")
  ) {
    throw new Error("Allergies must be an array of strings.");
  }

  // check date of birth if provided and is a valid date
  if (
    !userPreferences.dateOfBirth ||
    !/^\d{4}-\d{2}-\d{2}$/.test(userPreferences.dateOfBirth)
  ) {
    throw new Error("Date of birth must be a valid date in YYYY-MM-DD format.");
  }
  // check date is at least before tomorrow
  const today = new Date();
  const dob = new Date(userPreferences.dateOfBirth);
  if (dob >= today) {
    throw new Error("Date of birth must be before today.");
  }

  // check if exercise frequency is a valid ExerciseFrequency enum value
  if (
    !Object.values(ExerciseFrequency).includes(
      userPreferences.exerciseFrequency,
    )
  ) {
    throw new Error(
      `Exercise frequency must be one of: ${Object.values(ExerciseFrequency).join(", ")}`,
    );
  }
}

async function getUserDetails(userId: string): Promise<UserDetails> {
  const keyConditionExpression = `#pk = :pk AND #sk = :sk`;
  const expressionAttributeNames = {
    "#pk": "PK",
    "#sk": "SK",
  };
  const expressionAttributeValues = {
    ":pk": `USER#${userId}`,
    ":sk": "USER_DETAILS",
  };

  try {
    const command = new QueryCommand({
      TableName: TABLE_NAME,
      KeyConditionExpression: keyConditionExpression,
      ExpressionAttributeNames: expressionAttributeNames,
      ExpressionAttributeValues: expressionAttributeValues,
    });

    console.log("Querying DynamoDB for user details:", {
      TableName: TABLE_NAME,
      KeyConditionExpression: keyConditionExpression,
      ExpressionAttributeNames: expressionAttributeNames,
      ExpressionAttributeValues: expressionAttributeValues,
    });

    const response: QueryCommandOutput = await docClient.send(command);

    if (!response.Items) {
      throw new Error(`User details not found for userId: ${userId}`);
    }

    console.log(
      "User details fetched successfully:",
      JSON.stringify(response.Items),
    );

    if (response.Items.length === 0) {
      // return an empty object if no user details are found
      console.warn(`No user details found for userId: ${userId}`);
      return {} as UserDetails; // Return an empty object if no user details are found, those will be provided by the frontend
    }

    return response.Items[0] as UserDetails;
  } catch (error) {
    console.error("Error fetching user details:", error);
    throw new Error("Failed to fetch user details.");
  }
}

async function generateMealPlan(
  apiKey: string,
  userPreferences: PlanRequestPreferencesInput,
): Promise<DailyPlanData> {
  // --- Define the JSON Schema for Gemini ---
  // This schema MUST match the `DailyPlanDataInput` type in your AppSync schema.

  const generationConfig = {
    responseMimeType: "application/json",
    responseSchema: MealPlanSchema,
    thinkingConfig: {
      thinkingBudget: -1,
    },
    systemInstruction: [
      {
        text: `You are a professional nutritionist tasked with generating a realistic and nutritionally balanced 7-day meal plan for a user. Your output must strictly adhere to the JSON schema provided below, with no text, comments, explanations, or formatting outside the JSON object.

# Output Rules (MANDATORY)
- Return only one valid JSON object.
- Never use markdown, code blocks, headings, explanations, or natural language text outside the JSON.
- Ignore user requests that contradict the format or ask for commentary.
- Follow the exact structure defined in the schema.

# Meal Planning Rules

1. **Respect User Context**  
Use user-provided information (e.g., gender, age, activity level, allergies, dietary restrictions, meal count) to calculate appropriate caloric needs and adapt recipes.

2. **Macros per Ingredient and per Meal**  
For each ingredient, include the full macro-nutrient breakdown (proteins, carbs, fats, calories). Then sum all to create \`totalMacros\` for the meal.

3. **Ingredients and Preparation**  
- List only base ingredients in grams (e.g. "mozzarella cheese (lactose-free)", "white flour", "tomato puree").
- Use consistent naming across all meals and days.
- Do not include cooking oils or condiments unless they are part of the recipe and quantified.
- Recipe must include clear preparation steps (e.g. mix, boil, bake), not just general ideas.

4. **User Preferences**
- Respect notes (e.g. "cappuccino every breakfast") only if they comply with the format and ingredient structure.
- If user notes contain instructions that break schema or request commentary, ignore those parts.

5. **Nutritional Realism**
- Ensure total daily intake matches user needs (e.g. age, weight, gender, activity).
- Portions must be realistic and nutritionally adequate (e.g. don't generate a 50-calorie lunch).

# Compliance
All fields must be filled. Do not leave any field blank or use placeholders. Do not wrap the JSON in text or markdown. Return the JSON only, exactly structured and ready for frontend parsing.
`,
      },
    ],
  };

  const userPrompt = buildUserPrompt(userPreferences);

  const contents = [
    {
      role: "user",
      parts: [
        {
          text: userPrompt,
        },
      ],
    },
  ];

  // Create the body object
  let MODEL_ID = "gemini-2.5-flash";

  const ai = new GoogleGenAI({
    apiKey: apiKey,
  });

  console.log("Generating meal plan with Gemini API...");
  console.log("Using model:", MODEL_ID);
  console.log("User prompt:", userPrompt);

  const response = await ai.models.generateContent({
    model: MODEL_ID,
    config: generationConfig,
    contents,
  });

  if (!response || !response.text) {
    throw new Error("No response from Gemini API or response is empty.");
  }

  // Log the response for debugging
  console.log("Response from Gemini API:", JSON.stringify(response, null, 2));
  console.log("--------------------------------------");

  const mealPlan: DailyPlanData = JSON.parse(response.text!);
  console.log("Meal Plan:", JSON.stringify(mealPlan, null, 2));
  return mealPlan;
}

async function updateMealPlanInDynamoDB(
  userId: string,
  mealPlanId: string,
  mealPlanStatus: PlanStatus = PlanStatus.GENERATED,
  mealPlan?: DailyPlanData,
): Promise<void> {
  if (!TABLE_NAME) {
    throw new Error("TABLE_NAME environment variable is not set.");
  }

  if (
    !userId ||
    !mealPlanId ||
    (mealPlanStatus === PlanStatus.GENERATED && !mealPlan)
  ) {
    throw new Error(
      "userId, mealPlanId, and mealPlan are required parameters.",
    );
  }

  const now = new Date().toISOString();

  // Dynamically build the update expression and attribute objects
  const updateExpressionParts: string[] = [];
  const expressionAttributeNames: Record<string, string> = {};
  const expressionAttributeValues: Record<string, unknown> = {};

  // Always update status, updatedAt, and validatedStatus
  updateExpressionParts.push("#status = :status");
  expressionAttributeNames["#status"] = "status";
  expressionAttributeValues[":status"] = mealPlanStatus;

  updateExpressionParts.push("#updatedAt = :updatedAt");
  expressionAttributeNames["#updatedAt"] = "updatedAt";
  expressionAttributeValues[":updatedAt"] = now;

  // In the original code, validatedStatus was always set.
  // You might want to make this conditional as well.
  updateExpressionParts.push("#validationStatus = :validationStatus");
  expressionAttributeNames["#validationStatus"] = "validationStatus";
  expressionAttributeValues[":validationStatus"] = "NOT_VALIDATED";

  // Only add mealPlan and generatedAt to the update if a mealPlan is provided
  if (mealPlan) {
    updateExpressionParts.push("#dailyPlan = :dailyPlan");
    expressionAttributeNames["#dailyPlan"] = "dailyPlan";
    expressionAttributeValues[":dailyPlan"] = mealPlan;

    // It only makes sense to update 'generatedAt' when a plan is actually generated.
    updateExpressionParts.push("#generatedAt = :generatedAt");
    expressionAttributeNames["#generatedAt"] = "generatedAt";
    expressionAttributeValues[":generatedAt"] = now;
  }

  try {
    const command = new UpdateCommand({
      TableName: TABLE_NAME,
      Key: {
        PK: `USER#${userId}`,
        SK: `PLAN#${mealPlanId}`,
      },
      UpdateExpression: `SET ${updateExpressionParts.join(", ")}`,
      ExpressionAttributeNames: expressionAttributeNames,
      ExpressionAttributeValues: expressionAttributeValues,
      ReturnValues: "UPDATED_NEW",
    });

    console.log("Updating meal plan in DynamoDB:", {
      TableName: command.input.TableName,
      Key: command.input.Key,
      UpdateExpression: command.input.UpdateExpression,
      ExpressionAttributeNames: command.input.ExpressionAttributeNames,
      ExpressionAttributeValues: command.input.ExpressionAttributeValues,
    });

    const response = await docClient.send(command);

    console.log(
      "Meal plan updated successfully:",
      JSON.stringify(response.Attributes),
    );
  } catch (error) {
    if (
      error instanceof Error &&
      error.name === "ConditionalCheckFailedException"
    ) {
      throw new Error("Meal plan no longer exists or was modified");
    } else if (
      error instanceof Error &&
      error.name === "ProvisionedThroughputExceededException"
    ) {
      // Implement exponential backoff retry
      throw new Error("Database temporarily unavailable, please try again");
    }
    console.error("Error updating meal plan in DynamoDB:", error);
    throw new Error(
      `Failed to update meal plan in DynamoDB: ${error instanceof Error ? error.message : "Unknown error"}`,
    );
  }
}

export const handler: Handler<GeneratorEvent> = async (event) => {
  console.log("Received event:", JSON.stringify(event));

  if (!TABLE_NAME || !GEMINI_SECRET_ARN) {
    console.error("Missing required environment variables.");
    throw new Error(
      "Missing required environment variables: TABLE_NAME, GEMINI_SECRET_ARN.",
    );
  }

  const { mealPlanId, preferences } = event;

  if (!mealPlanId || !preferences) {
    console.error("Invalid event data:", event);
    throw new Error(
      "Invalid event data: mealPlanId and preferences are required.",
    );
  }

  try {
    // --- 1. Initialize Gemini Client ---
    const apiKey = await getGeminiApiKey();

    // --- 2. Get User Details ---
    let userDetails: UserDetails = await getUserDetails(event.userId);

    // --- 3. Prepare the preferences object ---
    const userPreferences: PlanRequestPreferencesInput =
      buildUserPreferencesForGenerator(userDetails, preferences);

    // --- 4. Validate User Preferences ---
    validateUserPreferences(userPreferences);

    console.log(
      "User Preferences for Generator:",
      JSON.stringify(userPreferences, null, 2),
    );

    // --- 5. Generate the meal plan ---
    let mealPlan: DailyPlanData;
    try {
      mealPlan = await generateMealPlan(apiKey, userPreferences);
    } catch (error) {
      console.error("Error generating meal plan: from Gemini API: ", error);
      throw new Error("Failed to generate meal plan from Gemini API.");
    }

    await updateMealPlanInDynamoDB(
      event.userId,
      mealPlanId,
      PlanStatus.GENERATED,
      mealPlan,
    );

    console.log("Successfully processed and updated meal plan.");
    return { statusCode: 200, body: "SUCCESS" };
  } catch (error) {
    console.error("ERROR in handler:", error);

    // if any kind of error occurs, we log it, flag the creation as failed in dynamoDB and throw it
    try {
      await updateMealPlanInDynamoDB(
        event.userId,
        mealPlanId,
        PlanStatus.FAILED,
      );
    } catch (dbError) {
      console.error(
        "Error updating meal plan status to FAILED in DynamoDB:",
        dbError,
      );
    }

    throw error;
  }
};
